---
title: Request
---

A request describes the shape of an incoming HTTP request. Each aspect of a request has its own DSL for type-safe composition.

```haskell
input
  = request
  & method GET
  & path do
      lit "users"
      userId <- capture @Int "id"
      pure userId
  & query do
      page <- page .= param @Int "page"
      pure page
  & headers none
  & body none
  & security none
```

## Method

The Method DSL specifies which HTTP method(s) the request accepts.

```haskell
input = request
  & method GET
```

### Available Methods

```haskell
method GET
method POST
method PUT
method DELETE
method PATCH
method HEAD
method OPTIONS
```

## Path

The Path DSL defines URL path matching and parameter extraction.

```haskell
path do
  lit "users"
  userId <- capture @Int "id"
  lit "posts"
  postId <- capture @Int "postId"
  pure (userId, postId)
```

### Literal Segments

Match exact path segments:

```haskell
lit "users"
lit "api"
lit "v1"
```

### Capture Parameters

Extract typed values from path segments:

```haskell
capture @Int "id"
capture @Text "slug"
capture @UUID "uuid"
```

### Combining Paths

Use do-notation to combine path operations:

```haskell
path do
  lit "api"
  lit "v1"
  lit "users"
  userId <- capture @Int "id"
  pure userId
```

## Query

The Query DSL extracts and validates query string parameters.

```haskell
query do
  page <- page .= param @Int "page"
  limit <- limit .= param @Int "limit"
  pure Pagination {..}
```

### Required Parameters

```haskell
param @Int "page"
param @Text "search"
```

### Optional Parameters

```haskell
optional @Int "page"
```

### Default Values

```haskell
withDefault 1 (param @Int "page")
```

### Building Records

Use `RecordWildCards` to build records from query parameters:

```haskell
data Pagination = Pagination
  { page :: Int
  , limit :: Int
  }

query do
  page <- page .= param @Int "page"
  limit <- limit .= param @Int "limit"
  pure Pagination {..}
```

## Headers

The Headers DSL extracts and validates HTTP request headers.

```haskell
headers do
  auth <- header @Text "Authorization"
  contentType <- header @Text "Content-Type"
  pure (auth, contentType)
```

### Required Headers

```haskell
header @Text "Authorization"
header @Text "X-API-Key"
```

### Optional Headers

```haskell
optionalHeader @Text "X-Request-Id"
```

### No Headers

When no headers are needed:

```haskell
headers none
```

## Body

The Body DSL specifies the expected request body type.

```haskell
body @Value
body @CreateUserRequest
body @Text
```

### JSON Body

Parse the request body as JSON into a type:

```haskell
data CreateUser = CreateUser
  { name :: Text
  , email :: Text
  }

body @CreateUser
```

### Raw Body

Accept raw text or bytes:

```haskell
body @Text
body @ByteString
```

### No Body

When no body is expected:

```haskell
body none
```

## Security

The Security DSL defines authentication and authorization requirements.

```haskell
security bearerAuth
security apiKeyAuth
security none
```

### Bearer Token

```haskell
security bearerAuth
```

### API Key

```haskell
security apiKeyAuth
```

### No Authentication

```haskell
security none
```

### Custom Security

Define custom security schemes for your application.
